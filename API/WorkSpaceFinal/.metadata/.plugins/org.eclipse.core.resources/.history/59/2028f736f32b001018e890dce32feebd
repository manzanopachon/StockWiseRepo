package com.dam.restaurante.service;



import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.dam.restaurante.dto.CategoriaDTO;
import com.dam.restaurante.dto.PlatoDTO;
import com.dam.restaurante.dto.PlatoIngredienteDTO;
import com.dam.restaurante.model.Categoria;
import com.dam.restaurante.model.Ingrediente;
import com.dam.restaurante.model.Plato;
import com.dam.restaurante.model.PlatoIngrediente;
import com.dam.restaurante.model.Restaurante;
import com.dam.restaurante.repository.CategoriaRepository;
import com.dam.restaurante.repository.IngredienteRepository;
import com.dam.restaurante.repository.PlatoIngredienteRepository;
import com.dam.restaurante.repository.PlatoRepository;
import com.dam.restaurante.repository.RestauranteRepository;

@Service
public class PlatoService {

    @Autowired
    private PlatoRepository platoRepository;

    @Autowired
    private CategoriaRepository categoriaRepository;
    
    @Autowired
    private IngredienteRepository ingredienteRepository;

    @Autowired
    private PlatoIngredienteRepository platoIngredienteRepository;
    
    @Autowired
    private RestauranteRepository restauranteRepository;

    public List<PlatoDTO> obtenerTodos() {
        return platoRepository.findAll().stream().map(this::convertirAPlatoDTO).collect(Collectors.toList());
    }

    public List<PlatoDTO> obtenerTodoPlatos() {
        return platoRepository.findAll().stream()
                .map(this::convertirAPlatoDTO)
                .collect(Collectors.toList());
    }
    
    public List<PlatoDTO> obtenerPorRestauranteId(Long restauranteId) {
        
        return platoRepository.findAll().stream()
                .filter(p -> p.getRestaurante().getId().equals(restauranteId))
                .map(this::convertirAPlatoDTO)
                .collect(Collectors.toList());
    }
    
    
    public PlatoDTO obtenerPorId(Long id) {
        return platoRepository.findById(id)
                .map(this::convertirAPlatoDTO)
                .orElseThrow(() -> new RuntimeException("Plato no encontrado"));
    }

    public PlatoDTO crearPlato(PlatoDTO dto) {
        Plato nuevo = new Plato();
        nuevo.setNombre(dto.getNombre());
        nuevo.setDescripcion(dto.getDescripcion());
        nuevo.setPrecio(dto.getPrecio());

        // Sigue siendo correcto ya que dto.getCategoria() devuelve un CategoriaDTO
        String nombreCategoria = dto.getCategoria().getNombre();
        Categoria categoria = categoriaRepository.findByNombre(nombreCategoria)
                .orElseThrow(() -> new RuntimeException("Categoría no encontrada: " + nombreCategoria));
        nuevo.setCategoria(categoria);

        Restaurante restaurante = restauranteRepository.findById(dto.getRestauranteId())
                .orElseThrow(() -> new RuntimeException("Restaurante no encontrado"));
        nuevo.setRestaurante(restaurante);

        return convertirAPlatoDTO(platoRepository.save(nuevo));
    }



    public PlatoDTO actualizarPlato(Long id, PlatoDTO dto) {
        Plato existente = platoRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Plato no encontrado"));

        existente.setNombre(dto.getNombre());
        existente.setDescripcion(dto.getDescripcion());
        existente.setPrecio(dto.getPrecio());

        String nombreCategoria = dto.getCategoria().getNombre(); // <-- CAMBIO
        Categoria categoria = categoriaRepository.findByNombre(nombreCategoria)
                .orElseThrow(() -> new RuntimeException("Categoría no encontrada: " + nombreCategoria));
        existente.setCategoria(categoria);

        Restaurante restaurante = restauranteRepository.findById(dto.getRestauranteId())
                .orElseThrow(() -> new RuntimeException("Restaurante no encontrado"));
        existente.setRestaurante(restaurante);

        return convertirAPlatoDTO(platoRepository.save(existente));
    }

    public void eliminarPlato(Long id) {
        platoRepository.deleteById(id);
    }

    private PlatoDTO convertirAPlatoDTO(Plato p) {
        Categoria categoria = p.getCategoria();
        Long restauranteId = p.getRestaurante() != null ? p.getRestaurante().getId() : null;

        CategoriaDTO categoriaDTO = categoria != null ? new CategoriaDTO(categoria.getNombre()) : null;

        return new PlatoDTO(
                p.getId(),
                p.getNombre(),
                p.getDescripcion(),
                p.getPrecio(),
                categoriaDTO, // <-- CAMBIO
                restauranteId,
                null
        );
    }

    
    public void asignarIngredientesAPlato(Long platoId, Map<Long, Double> ingredientesConCantidad) {
        Plato plato = platoRepository.findById(platoId)
                .orElseThrow(() -> new RuntimeException("Plato no encontrado con ID: " + platoId));

        // Elimina relaciones anteriores si las hubiera
        platoIngredienteRepository.deleteByPlatoId(platoId);

        // Recorremos el mapa de ingredientes y cantidad
        for (Map.Entry<Long, Double> entry : ingredientesConCantidad.entrySet()) {
            Long ingredienteId = entry.getKey();
            Double cantidad = entry.getValue();

            Ingrediente ingrediente = ingredienteRepository.findById(ingredienteId)
                    .orElseThrow(() -> new RuntimeException("Ingrediente no encontrado con ID: " + ingredienteId));

            PlatoIngrediente relacion = new PlatoIngrediente();
            relacion.setPlato(plato);
            relacion.setIngrediente(ingrediente);
            relacion.setCantidadNecesaria(cantidad);

            platoIngredienteRepository.save(relacion);
        }
    }
    
 // Modificar cantidad
    public void modificarCantidadIngrediente(Long platoId, Long ingredienteId, Double nuevaCantidad) {
        PlatoIngrediente relacion = platoIngredienteRepository.findByPlatoIdAndIngredienteId(platoId, ingredienteId)
                .orElseThrow(() -> new RuntimeException("Relación no encontrada"));
        relacion.setCantidadNecesaria(nuevaCantidad);
        platoIngredienteRepository.save(relacion);
    }

    public void eliminarIngredienteDePlato(Long platoId, Long ingredienteId) {
        // Obtener el plato
        Plato plato = platoRepository.findById(platoId)
                .orElseThrow(() -> new RuntimeException("Plato no encontrado con ID: " + platoId));

        // Obtener el ingrediente
        Ingrediente ingrediente = ingredienteRepository.findById(ingredienteId)
                .orElseThrow(() -> new RuntimeException("Ingrediente no encontrado con ID: " + ingredienteId));

        // Eliminar la relación entre plato e ingrediente
        platoIngredienteRepository.deleteByPlatoAndIngrediente(plato, ingrediente);
    }

    // Obtener ingredientes de un plato
    public List<PlatoIngrediente> obtenerIngredientesDePlato(Long platoId) {
        return platoIngredienteRepository.findByPlatoId(platoId);
    }
    
    public List<PlatoIngredienteDTO> obtenerIngredientesDePlatoDTO(Long platoId) {
        List<PlatoIngrediente> relaciones = platoIngredienteRepository.findByPlatoId(platoId);

        return relaciones.stream().map(relacion -> {
            Ingrediente ingrediente = relacion.getIngrediente();
            return new PlatoIngredienteDTO(
                    ingrediente.getId(),
                    ingrediente.getNombre(),
                    ingrediente.getUnidadMedida(),
                    ingrediente.getCantidadStock(),
                    relacion.getCantidadNecesaria()
            );
        }).collect(Collectors.toList());
    }
    
 // Obtener todos los platos con sus ingredientes
    public List<PlatoDTO> obtenerTodosConIngredientes() {
        return platoRepository.findAll().stream()
                .map(plato -> {
                    List<PlatoIngredienteDTO> ingredientes = obtenerIngredientesDePlatoDTO(plato.getId());
                    PlatoDTO dto = convertirAPlatoDTO(plato);
                    dto.setIngredientes(ingredientes);
                    return dto;
                })
                .collect(Collectors.toList());
    }

    // Obtener platos por restaurante con ingredientes incluidos
    public List<PlatoDTO> obtenerPorRestauranteConIngredientes(Long restauranteId) {
        return platoRepository.findAll().stream()
                .filter(p -> p.getRestaurante().getId().equals(restauranteId))
                .map(plato -> {
                    List<PlatoIngredienteDTO> ingredientes = obtenerIngredientesDePlatoDTO(plato.getId());
                    PlatoDTO dto = convertirAPlatoDTO(plato);
                    dto.setIngredientes(ingredientes);
                    return dto;
                })
                .collect(Collectors.toList());
    }

    // Reasignar todos los ingredientes de un plato (sobrescribe los actuales)
    public void reasignarIngredientesPlato(Long platoId, List<PlatoIngredienteDTO> nuevosIngredientes) {
        Plato plato = platoRepository.findById(platoId)
                .orElseThrow(() -> new RuntimeException("Plato no encontrado con ID: " + platoId));

        // Eliminar relaciones existentes
        platoIngredienteRepository.deleteByPlatoId(platoId);

        // Crear nuevas relaciones
        for (PlatoIngredienteDTO dto : nuevosIngredientes) {
            Ingrediente ingrediente = ingredienteRepository.findById(dto.getIngredienteId())
                    .orElseThrow(() -> new RuntimeException("Ingrediente no encontrado con ID: " + dto.getIngredienteId()));

            PlatoIngrediente relacion = new PlatoIngrediente();
            relacion.setPlato(plato);
            relacion.setIngrediente(ingrediente);
            relacion.setCantidadNecesaria(dto.getCantidadNecesaria());

            platoIngredienteRepository.save(relacion);
        }
    }



}
